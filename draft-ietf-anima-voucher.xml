<?xml version='1.0'?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">

<?rfc toc="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes" ?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<?rfc linkmailto="no" ?>
<?rfc editing="no" ?>
<?rfc comments="yes" ?>
<?rfc inline="yes"?>
<?rfc rfcedstyle="yes"?>
<?rfc-ext allow-markup-in-artwork="yes" ?>
<?rfc-ext include-index="no" ?>
<!--<?rfc strict="no"?> -->

<rfc category="std"
     ipr="trust200902"
     docName="draft-ietf-anima-voucher-latest">
    <front>
        <title abbrev="Voucher Profile">Voucher Profile for Bootstrapping Protocols</title>
        <author initials="K.W." surname="Watsen" fullname="Kent Watsen">
            <organization>Juniper Networks</organization>
            <address>
                <email>kwatsen@juniper.net</email>
            </address>
        </author>
        <author fullname="Michael C. Richardson" initials="M." surname="Richardson">
          <organization>Sandelman Software</organization>
          <address>
            <email>mcr+ietf@sandelman.ca</email>
            <uri>http://www.sandelman.ca/</uri>
          </address>
        </author>
        <author initials="M.P." surname="Pritikin" fullname="Max Pritikin">
            <organization>Cisco Systems</organization>
            <address>
                <email>pritikin@cisco.com</email>
            </address>
        </author>
        <author fullname="Toerless Eckert" initials="T.T.E." surname="Eckert">
          <organization abbrev="Huawei">Futurewei Technologies Inc.</organization>
          <address>
            <postal>
              <street>2330 Central Expy</street>
              <city>Santa Clara</city>
              <code>95050</code>
              <country>USA</country>
            </postal>
            <email>tte+ietf@cs.fau.de</email>
          </address>
        </author>

        <date/>
        <area>Operations</area>
        <workgroup>ANIMA Working Group</workgroup>
        <keyword>voucher</keyword>
        <abstract>
          <t>This document defines a strategy to securely assign a pledge to an owner,
          using an artifact signed, directly or indirectly, by the pledge's manufacturer.
          This artifact is known as a "voucher".</t>

          <t>
            This document defines an artifact format as a YANG-defined JSON document
            that has been signed using a CMS structure.  Other YANG-derived formats are possible.
            The voucher artifact is normally generated by
            the pledge's manufacturer (i.e. the Manufacturer Authorized Signing
            Authority).
          </t>

          <t>This document only defines the voucher artifact, leaving it to other
          documents to describe specialized protocols for accessing it.</t>
        </abstract>
    </front>

    <middle>
      <section title="Introduction" anchor="introduction">

        <t>This document defines a strategy to securely assign a candidate device
        (pledge) to an owner, using an artifact signed, directly or indirectly,
        by the pledge's manufacturer, i.e. the Manufacturer Authorized
        Signing Authority (MASA).  This artifact is known as the voucher.</t>

        <t>The voucher artifact is a JSON <xref target="RFC7159"/> document,
        conforming to a data model described by YANG <xref target="RFC7950"/>,
        encoded using the rules defined in <xref target="RFC7159"/>, and
        signed using (by default) a CMS structure <xref target="RFC5652"/>.</t>

        <t>A voucher's primary purpose is to securely convey to a pledge a
        certificate, the "pinned-domain-cert", that the pledge can then use
        to authenticate subsequent interactions.  A voucher may be useful
        in several contexts but the driving motivation
        herein is to support secure bootstrapping mechanisms.  Assigning
        ownership is important to bootstrapping mechanisms so that the pledge
        can authenticate the network that is trying to take control of it.</t>

        <t>The lifetimes of vouchers may vary. In some bootstrapping protocols the vouchers may include a nonce restricting them to a single use, whereas in others the vouchers may have an indicated lifetime. In order to support long lifetimes this document recommends using short lifetimes with programmatic renewal, see <xref target="renewal-over-revocation"/>.</t>

        <t>This document only defines the voucher artifact, leaving it to other
        documents to describe specialized protocols for accessing it.  Some bootstrapping
        protocols using the voucher artifact defined in this draft include:
        <xref target="I-D.ietf-netconf-zerotouch"/>,
        <xref target="I-D.ietf-6tisch-dtsecurity-secure-join"/>, and
        <xref target="I-D.ietf-anima-bootstrapping-keyinfra"/>).</t>
      </section>

      <section title="Terminology">
        <t>This document uses the following terms (sorted by name):</t>
        <t><list style="hanging">
        <t hangText="Artifact:"> The term "artifact" is used throughout to represent the
            voucher as instantiated in the form of a signed structure.</t>
        <t hangText="Imprint:">The process where a device obtains the
            cryptographic key material to identify and trust future
            interactions with a network. This term is taken from Konrad
            Lorenz's work in biology with new ducklings: "during a critical
            period, the duckling would assume that anything that looks like a
            mother duck is in fact their mother." An equivalent for a device is
            to obtain the fingerprint of the network's root certification
            authority certificate. A device that imprints on an attacker
            suffers a similar fate to a duckling that imprints on a hungry
            wolf.  Imprinting is a term from psychology and ethnology, as describe in <xref target="imprinting"></xref>. 
            The analogy to Lorenz's work was first noted in <xref
                target="Stajano99theresurrecting"></xref>.</t>

          <t hangText="Domain:">The set of entities or infrastructure under
            common administrative control.  The goal of the bootstrapping
            protocol is to enable a Pledge to discover and join a domain.</t>

          <t hangText="Join Registrar (and Coordinator):">A representative of the domain that is
            configured, perhaps autonomically, to decide whether a new device
            is allowed to join the domain. The administrator of the domain
            interfaces with a Join Registrar (and Coordinator) to control this process.
            Typically a Join Registrar is "inside" its domain. For simplicity this document
            often refers to this as just "Registrar".</t>

          <t hangText="MASA:">The Manufacturer Authorized Signing Authority (MASA)
            is the entity that, for the purpose of this document, signs the
            vouchers for a manufacturer's pledges.  In some bootstrapping protocols, the
            MASA may have Internet presence and be integral to the bootstrapping
            process, whereas in other protocols the MASA may be an offline service
            that has no active role in the bootstrapping process.</t>

          <t hangText="Owner:">The entity that controls the private key of the
          "pinned-domain-cert" certificate conveyed by the voucher.</t>

          <t hangText="Pledge:">The prospective device attempting to find and
            securely join a domain.  When shipped it only trusts authorized
            representatives of the manufacturer.</t>

          <t hangText="Registrar">See Join Registrar</t>

          <t hangText="TOFU:">Trust on First Use. This is where a Pledge
            device makes no security decisions but rather simply trusts the
            first domain entity it is contacted by.  Used similarly to <xref
            target="RFC7435"/>. This is also known as the "resurrecting
            duckling" model.</t>

          <t hangText="Voucher:">A signed statement from the MASA service
            that indicates to a Pledge the cryptographic identity of the
            domain it should trust.</t>

        </list></t>
      </section>

      <section title="Requirements Language">
        <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
        NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED",
        "MAY", and "OPTIONAL" in this document are to be interpreted as
        described in BCP 14 <xref target="RFC2119"/> <xref target="RFC8174"/>
        when, and only when, they appear in all capitals, as shown here.</t>
      </section>

      <section title="Survey of Voucher Types">

          <t>A voucher is a cryptographically protected statement to the Pledge
              device authorizing a zero-touch "imprint" on the Join Registrar of the
              domain. The specific information a voucher provides is influenced by the
              bootstrapping use case.</t>

              <t>The voucher can impart the following information to
              the Join Registrar and Pledge:</t>

          <t><list style="hanging">
              <t hangText="Assertion Basis:">Indicates the method that protects
                  the imprint (this is distinct from the voucher signature that
                  protects the voucher itself). This might include manufacturer
                  asserted ownership verification, assured logging operations or
                  reliance on Pledge endpoint behavior such as secure root of trust
                  of measurement. The Join Registrar might use this information.
                  Only some methods are normatively defined in this
                  document. Other methods are left for future work.</t>

              <t hangText="Authentication of Join Registrar:">Indicates how the Pledge
                  can authenticate the Join Registrar.  This document defines
                  a mechanism to pin the domain certificate.
                  Pinning a symmetric key, a raw
                  key, or <xref target="RFC6125"/> style "CN-ID" 
                  or "DNS-ID" information is left for future work.
              </t>

              <t hangText="Anti-Replay Protections:">Time or nonce based
                  information to constrain the voucher to time periods or bootstrap
                  attempts.</t>
          </list></t>

          <t>A number of bootstrapping scenarios can be met using differing
              combinations of this information. All scenarios address the primary
              threat of a Man-in-The-Middle (MiTM) Registrar gaining control over the Pledge device. The
              following combinations are "types" of vouchers:</t>

          <figure>
              <artwork><![CDATA[
             |Assertion   |Registrar ID    | Validity    |
Voucher      |Log-|Veri-  |Trust  |CN-ID or| RTC | Nonce |
Type         | ged|  fied |Anchor |DNS-ID  |     |       |
---------------------------------------------------------|
Audit        |  X |       | X     |        |     | X     |
-------------|----|-------|-------|--------|-----|-------|
Nonceless    |  X |       | X     |        | X   |       |
Audit        |    |       |       |        |     |       |
-------------|----|-------|-------|--------|-----|-------|
Owner Audit  |  X |   X   | X     |        | X   | X     |
-------------|----|-------|-------|--------|-----|-------|
Owner ID     |    |   X   | X     |  X     | X   |       |
-------------|----|-------|----------------|-----|-------|
Bearer       |  X |       |   wildcard     | optional    |
out-of-scope |    |       |                |             |
-------------|----|-------|----------------|-------------|

NOTE: All voucher types include a 'Pledge ID serial number'
      (Not shown for space reasons)
              ]]></artwork>
          </figure>

          <t><list style="hanging">
              <t hangText="Audit Voucher:">An Audit Voucher is named after the
                  logging assertion mechanisms that the Registrar then "audits" to
                  enforce local policy. The Registrar mitigates a MiTM Registrar by
                  auditing that an unknown MiTM registrar does not appear in the log
                  entries. This does not directly prevent the MiTM but provides a
                  response mechanism that ensures the MiTM is unsuccessful. This
                  advantage is that actual ownership knowledge is not required on
                  the MASA service.</t>

              <t hangText="Nonceless Audit Voucher:">An Audit Voucher without a
                  validity period statement. Fundamentally the same as an Audit
                  Voucher except that it can be issued in advance to support network
                  partitions or to provide a permanent voucher for remote
                  deployments.</t>

              <t hangText="Ownership Audit Voucher:">An Audit Voucher where the
                  MASA service has verified the Registrar as the authorized owner.
                  The MASA service mitigates a MiTM Registrar by refusing to
                  generate Audit Vouchers for unauthorized Registrars. The
                  Registrar uses audit techniques to supplement the MASA. This
                  provides a ideal sharing of policy decisions and enforcement
                  between the vendor and the owner.</t>

              <t hangText="Ownership ID Voucher:">An Ownership ID Voucher is
                  named after inclusion of the Pledge's CN-ID or DNS-ID within the
                  voucher. The MASA service
                  mitigates a MiTM Registrar by identifying the specific Registrar
                  (via WebPKI) authorized to own the Pledge. </t>

              <t hangText="Bearer Voucher:">A Bearer Voucher is named after the
                  inclusion of a Registrar ID wildcard. Because the Registrar identity
                  is not indicated this voucher type must be treated as a
                  secret and protected from exposure as any 'bearer' of the voucher
                  can claim the Pledge device. Publishing a nonceless
                  bearer voucher effectively turns the specified Pledge into a
                  "TOFU" device with minimal mitigation against MiTM Registrars. Bearer
                  vouchers are out-of-scope.</t>
          </list></t>
      </section> <!-- end Imprint using Voucher -->

      <section title="Voucher artifact" anchor="voucher">

        <t>The voucher's primary purpose is to securely assign a pledge to an owner.
        The voucher informs the pledge which entity it should consider to be
        its owner.</t>

        <t>
          This document defines a voucher that is a JSON encoded instance of
          the YANG module defined in <xref target="voucher-yang-module" /> that has been, by default,  CMS-signed.
        </t>
        <t>
          This format is described here as a practical basis for
          some uses (such as in NETCONF), but more to make it clear what
          vouchers look like in practice.  This description also serves to
          validate the YANG model.
        </t>

        <t>
          Future work is expected to define new mappings of the voucher to
          CBOR (from JSON), and to change the signature container from CMS to
          JOSE or COSE.  XML or ASN.1 formats are also conceivable.
        </t>

        <t>
          This document defines MIME types and file name extension for the
          CMS encoded JSON type.  Future documents on additional formats
          would define additional MIME types.  Signaling is in the form of a MIME
          Content-Type, an HTTP Accept: header, or more mundane methods like
          use of a filename extension when a voucher is transfered on a USB
          key.
        </t>

        <section title="Tree Diagram" anchor="voucher-tree-diagram">
          <t>The following tree diagram illustrates a high-level view of a
          voucher document.  The notation used in this diagram is described
          in <xref target="I-D.ietf-netmod-yang-tree-diagrams"/>).  Each node in the diagram is
          fully described by the YANG module in <xref target="voucher-yang-module"/>.
          Please review the YANG module for a detailed description of the
          voucher format.</t>
          <figure>
            <artwork><![CDATA[
INSERT_TEXT_FROM_FILE(refs/ietf-voucher-tree.txt)
]]></artwork>
          </figure>
        </section>

        <section title="Examples" anchor="voucher-examples">
          <t>This section provides voucher examples for illustration
          purposes.  That these examples conform to the encoding rules
          defined in <xref target="RFC7159"/>.</t>

          <t>The following example illustrates an ephemeral voucher (uses a nonce).
             The MASA generated this voucher using the 'logged' assertion type, knowing
             that it would be suitable for the pledge making the request.</t>
          <figure>
            <artwork><![CDATA[
INSERT_TEXT_FROM_FILE(refs/ex-file-voucher-ephemeral.json)
]]></artwork>
          </figure>

          <t>The following example illustrates a non-ephemeral voucher (no nonce).
             While the voucher itself expires after two weeks, it presumably can
             be renewed for up to a year later.   The MASA generated this voucher
             using the 'verified' assertion type, which should satisfy all pledges.</t>
          <figure>
            <artwork><![CDATA[
INSERT_TEXT_FROM_FILE(refs/ex-file-voucher-long-lived.json)
]]></artwork>
          </figure>

        </section>  <!-- examples -->

        <section title="YANG Module" anchor="voucher-yang-module">

          <t>Following is a YANG <xref target="RFC7950"/> module formally
          describing the voucher's JSON document structure.</t>

          <figure>
            <artwork><![CDATA[
<CODE BEGINS> file "yang/ietf-voucher@YYYY-MM-DD.yang"
INSERT_TEXT_FROM_FILE(yang/ietf-voucher@YYYY-MM-DD.yang)
<CODE ENDS>
]]></artwork>
          </figure>
        </section>  <!-- yang module -->

        <section title="CMS format voucher artifact" anchor="cms-voucher">
          <t>
            The IETF evolution of PKCS#7 is CMS <xref target="RFC5652" />.
            A CMS signed voucher, the default type, contains a ContentInfo
            structure with the voucher content. An eContentType of TBD1
            indicates the content is a JSON-encoded voucher.
          </t>

          <t>
            The signing structure is a CMS SignedData structure, as specified
            by Section 5.1 of <xref target="RFC5652"/>.
          </t>

          <t>
            To facilitate these techniques, this document registers a MIME
            type for CMS-signed JSON in <xref target="vcj" />, plus a registration of
            a new MIME type along with its filename extension: 
            "application/voucher-cms+json" and ".vcj" 
          </t>

          <t>
            The CMS structure MUST contain a 'signerInfo' structure, as
            described in Section 5.1 of <xref target="RFC5652"/>, containing the
            signature generated over the content using a private key
            trusted by the recipient. Normally the recipient is the pledge and the
            signer is the MASA. A possible other use could be as a "signed
            voucher request" format originating from pledge or registrar
            toward the MASA.
            Within this document the signer is assumed to be the MASA.
          </t>

          <t>
            Note that Section 5.1 of <xref target="RFC5652"/> includes a
            discussion about how to validate a CMS object which is really a
            PKCS7 object (cmsVersion=1).  Intermediate systems (such the
            BRSKI Registrar) which might need to evaluate the voucher in
            flight MUST be prepared for such an older format.  No signaling
            is necessary, as the Manufacturer knows the capabilities of the
            pledge, and will use an appropriate format voucher for each
            pledge.
          </t>

          <t>
            The CMS structure SHOULD also contain all the certificates
            leading up to and including the signer's trust anchor certificate
            known to the recipient.  The inclusion of the trust anchor is
            unusual in many applications, but without it third parties can
            not accurately audit the transaction.
          </t>

          <t>
            The CMS structure MAY also contain revocation objects for any
            intermediate certificate authorities (CAs) between the
            voucher-issuer and the trust anchor known to the recipient.
            However, the use of CRLs and other validity mechanisms is
            discouraged, as the pledge is unlikely to be able to perform
            online checks, and is unlikely to have a trusted clock source.
            As described below, the use of short-lived vouchers and/or pledge
            provided nonce provides a freshness guarantee.
          </t>

        </section>
      </section>  <!-- voucher -->


      <section title="Design Considerations" anchor="design-con">

        <section title="Renewals instead of Revocations" anchor="renewal-over-revocation">

          <t>The lifetimes of vouchers may vary.  In some bootstrapping protocols, the
          vouchers may be created and consumed immediately whereas, in other bootstrapping
          solutions, there may be a significant time delay between when a voucher is created
          and when it is consumed.  In cases when there is a time delay, there is a need for
          the pledge to ensure that the assertions made when the voucher was created are
          still valid.</t>

          <t>A revocation artifact is generally used to verify the continued validity
          of an assertion such as a PKIX certificate, web token, or a "voucher".  With
          this approach, a potentially long-lived assertion is paired with a reasonably
          fresh revocation status check to ensure that the assertion is still valid.
          However, this approach increases solution complexity, as it introduces the
          need for additional protocols and code paths to distribute and process the
          revocations.</t>

          <t>Addressing the short-comings of revocations, this document recommends
          instead the use of lightweight renewals of short-lived non-revocable
          vouchers.  That is, rather than issue a long-lived voucher, where the
          'expires-on' leaf is set to some distant date, the expectation
          is for the MASA to instead issue a short-lived voucher, where the
          'expires-on' leaf is set to a relatively near date, along with a promise
          (reflected in the 'last-renewal-date' field) to re-issue the voucher again
          when needed.  Importantly, while issuing the initial voucher may incur
          heavyweight verification checks (are you who you say you are?  does the
          pledge actually belong to you?), re-issuing the voucher should be a
          lightweight process, as it ostensibly only updates the voucher's
          validity period.  With this approach, there is only the one artifact,
          and only one code path is needed to process it, without any possibility
          for a pledge to choose to skip the revocation status check because, for
          instance, the OCSP Responder is not reachable.</t>

          <t>While this document recommends issuing short-lived vouchers, the
          voucher artifact does not restrict the ability to create a long-lived
          vouchers, if required, however no revocation method is described.</t>

          <t>Note that a voucher may be signed by a chain of intermediate CAs
          leading up to the trust anchor certificate known by the pledge.  Even
          though the voucher itself is not revocable, it may still be revoked,
          per se, if one of the intermediate CA certificates is revoked.</t>
        </section>

        <section title="Voucher Per Pledge">
          <t>The solution described herein originally enabled a single voucher to
          apply to many pledges, using lists of regular expressions to represent
          ranges of serial numbers.  However, it was determined that blocking the
          renewal of a voucher that applied to many devices would be excessive
          when only the ownership for a single pledge needed to be blocked.
          Thus, the voucher format now only supports a single serial-number
          to be listed.</t>
        </section>
      </section>

      <section title="Security Considerations" anchor="sec-con">
        <section title="Clock Sensitivity">
          <t>
            An attacker could use an expired voucher to gain control over
            a device that has no understanding of time.  The device can not
            trust NTP as a time reference, as an attacker could control
            the NTP stream.
          </t>
          <t>
            To defend against this there are three things: devices are
            required to verify that the expires-on field has not yet passed.
            Devices without access to time can use nonces to
            get ephemeral vouchers.
            Thirdly, vouchers without expiration times may be used, which
            will appear in the audit log, informing the security decision.
          </t>

          <t>
            This document defines a voucher format that  contains time values
            for expirations, which require an accurate clock
            in order to be processed correctly.  Vendors planning on
            issuing vouchers with expiration values must ensure devices
            have an accurate clock when shipped from manufacturing
            facilities, and take steps to prevent clock tampering.
            If it is not possible to ensure clock accuracy then
            vouchers with expirations should not be issued.
          </t>
        </section>
        <section title="Protect Voucher PKI in HSM">
          <t>A voucher is signed by a CA, that may itself be signed by a chain of
          CAs leading to a trust anchor known to a pledge.  Revocation checking
          of the intermediate certificates may be difficult in some scenarios.
          The voucher format supports the existing PKIX revocation information
          distribution within the limits of the current PKI technology (a PKCS7
          structure can contain revocation objects as well), but pledges MAY
          accept vouchers without checking X.509 certificate revocation (when
          'domain-cert-revocation-checks' is false).  Without revocation checking,
          a compromised MASA keychain could be used to issue vouchers ad infinitum
          without recourse.  For this reason, MASA implementations wanting to
          support such deployments SHOULD ensure that all the CA private keys
          used for signing the vouchers are protected by hardware security
          modules (HSMs).</t>
        </section>
        <section title="Test Domain Certificate Validity when Signing">
          <t>If a domain certificate is compromised, then any outstanding
          vouchers for that domain could be used by the attacker.  The domain
          administrator is clearly expected to initiate revocation of any
          domain identity certificates (as is normal in PKI solutions).
          </t>
          <t>
          Similarly they are expected to contact the MASA to indicate that
          an outstanding (presumably short lifetime) voucher should be blocked from
          automated renewal. Protocols for voucher distribution are RECOMMENDED
          to check for revocation of any domain identity certificates before
          automated renewal of vouchers.</t>
        </section>
      </section>

      <section title="IANA Considerations" anchor="iana-considerations">

        <section title="The IETF XML Registry">
          <t>This document registers a URIs in the IETF XML
          registry <xref target="RFC3688"/>.  Following the format in
          <xref target="RFC3688"/>, the following registration is
          requested:</t>
          <t>
            <figure>
                <artwork><![CDATA[
   URI: urn:ietf:params:xml:ns:yang:ietf-voucher
   Registrant Contact: The ANIMA WG of the IETF.
   XML: N/A, the requested URI is an XML namespace.
]]></artwork>
            </figure>
          </t>
        </section>

        <section title="The YANG Module Names Registry">
          <t>This document registers a YANG module in the
          YANG Module Names registry <xref target="RFC6020"/>.
          Following the format defined in <xref target="RFC6020"/>, the
          the following registration is requested:</t>
          <t>
            <figure>
                <artwork><![CDATA[
   name:         ietf-voucher
   namespace:    urn:ietf:params:xml:ns:yang:ietf-voucher
   prefix:       vch
   reference:    RFC XXXX
]]></artwork>
          </figure>
        </t>
        </section>

        <section title="The IETF MIME Registry" anchor="vcj">
          <t>This document registers a URIs in the IETF XML
          registry <xref target="RFC3688"/>.  Following the format in
          <xref target="RFC3688"/>, the following registration is
          requested:</t>
          <t>
            <list style="hanging">
              <t hangText="Type name:">application</t>
              <t hangText="Subtype name:">voucher-cms+json</t>
              <t hangText="Required parameters:"> none</t>
              <t hangText="Optional parameters:"> none</t>
              <t hangText="Encoding considerations:"> CMS files are ASN.1/DER encoded, and therefore must
                 be encoded in non-binary contexts.</t>
              <t hangText="Security considerations:"> See Security
              Considerations, <xref target="sec-con" /></t>
              <t hangText="Interoperability considerations:">The format is
              designed to be broadly interoperable.</t>
              <t hangText="Published specification:"> THIS RFC. </t>
              <t hangText="Applications that use this media type:"> ANIMA,
              6tisch and NETCONF zero-touch imprinting systems</t>
              <t hangText="Additional information:">
                <list style="hanging">
                  <t hangText="Magic number(s):">None</t>
                  <t hangText="File extension(s):">.vcj</t>
                  <t hangText="Macintosh file type code(s):">none</t>
                </list>
              </t>
              <t hangText="Person &amp; email address to contact for further information:">IETF ANIMA WG</t>
              <t hangText="Intended usage:"> LIMITED</t>
              <t hangText="Restrictions on usage:"> NONE</t>
              <t hangText="Author:">ANIMA WG</t>
              <t hangText="Change controller:">IETF</t>
              <t hangText="Provisional registration? (standards tree only):">NO</t>
              </list>
          </t>
        </section>
        
        <section title="The SMI Security for S/MIME CMS Content Type  Registry">
          <t>
            This document registers an OID in the "SMI Security for S/MIME
            CMS Content Type" registry (1.2.840.113549.1.9.16.1), with the
            value:

            <figure>
                <artwork><![CDATA[
            Decimal  Description                             References
            -------  --------------------------------------  ----------
            TBD1      id-ct-animaJSONVoucher                 [ThisRFC]
]]></artwork>
            </figure>
          </t>
        </section>

      </section>

    </middle>

    <back>
      <references title="Normative References">
        <?rfc include="reference.RFC.2119.xml"?>
        <?rfc include="reference.RFC.5652.xml"?>
        <?rfc include="reference.RFC.6020.xml"?>
        <?rfc include="reference.RFC.7950.xml"?>
        <?rfc include="reference.RFC.7159.xml"?>
        <?rfc include="reference.RFC.8174.xml"?>

      </references>

      <references title="Informative References">
        <?rfc include="reference.RFC.3688.xml"?>
        <?rfc include="reference.I-D.ietf-netconf-zerotouch" ?>
        <?rfc include="reference.I-D.ietf-anima-bootstrapping-keyinfra" ?>
        <?rfc include="reference.I-D.ietf-6tisch-dtsecurity-secure-join" ?>
        <?rfc include="reference.I-D.ietf-netmod-yang-tree-diagrams" ?>
        <?rfc include="reference.RFC.6125.xml"?>
        <?rfc include="reference.RFC.7435" ?>

        <reference anchor="Stajano99theresurrecting"
            target="https://www.cl.cam.ac.uk/~fms27/papers/1999-StajanoAnd-duckling.pdf">
            <front>
                <title>The resurrecting duckling: security issues for ad-hoc
                    wireless networks</title>

                <author fullname="Frank Stajano" initials="F." surname="Stajano"></author>

                <author fullname="Ross Anderson" initials="R." surname="Anderson"></author>

                <date year="1999" />
            </front>
        </reference>
        <reference anchor="imprinting"
            target="https://en.wikipedia.org/wiki/Imprinting_(psychology)">
            <front>
                <title>Wikipedia article: Imprinting</title>

                <author surname="Wikipedia"></author>

                <date month="July" year="2015" />
            </front>
        </reference>

      </references>
      <section title="Acknowledgements">
        <t>The authors would like to thank for following for
        lively discussions on list and in the halls (ordered
        by last name): William Atwood, Toerless Eckert, Sheng Jiang.
        </t>
        <t>
          Russ Housley provided the upgrade from PKCS7 to CMS(RFC5652), along
          with the detailed CMS structure diagram.
        </t>
      </section>

      <section title="Example Vouchers">
        <t>
          Three entities are involved in a voucher: the MASA issues (signs)
          it, the registrar's public key is mentioned in the voucher, and the
          pledge validates it.  In order to provide reproduceable examples
          the public and private keys for an example MASA and Registrar are
          first listed.
        </t>
        <section title="MASA key pair">
          <t>
            Private key file:
          <figure>
            <artwork><![CDATA[
INSERT_TEXT_FROM_FILE(keys/masa_secp384r1.key)
]]></artwork>
          </figure>
          Public key file:
          <figure>
            <artwork><![CDATA[
INSERT_TEXT_FROM_FILE(keys/masa_secp384r1.crt)
]]></artwork>
          </figure>
          </t>
        </section>
        <section title="Registrar key pair">
          <t>
            Private key file:
          <figure>
            <artwork><![CDATA[
INSERT_TEXT_FROM_FILE(keys/jrc_prime256v1.key)
]]></artwork>
          </figure>
            Public key file:
          <figure>
            <artwork><![CDATA[
INSERT_TEXT_FROM_FILE(keys/jrc_prime256v1.crt)
]]></artwork>
          </figure>
          </t>
        </section>
        <section title="Example voucher">
          <t>
            RFC-EDITOR: these examples will need to be replaced with CMS
            versions once IANA has assigned the eContentType.
          </t>
          <t>
            Voucher artifact. The base64 has been wrapped at 60 characters
            for presentation reasons.  The voucher artifact does not have any
            PKCS-like "BEGIN"/"END" wrappers.
          <figure>
            <artwork><![CDATA[
INSERT_TEXT_FROM_FILE(examples/voucher_00-D0-E5-F2-00-02.pkcs)
]]></artwork>
          </figure>
          The ASN1 decoding of the artifact:
          <figure>
            <artwork><![CDATA[
INSERT_TEXT_FROM_FILE(examples/voucher_00-D0-E5-F2-00-02.asn1.txt)
]]></artwork>
          </figure>
          </t>
        </section>
      </section>
    </back>
</rfc>

